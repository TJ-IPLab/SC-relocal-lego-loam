MatrixXd SCManager::makeScancontext( pcl::PointCloud<SCPointType> & _scan_down )
{
    TicToc t_making_desc;

    int num_pts_scan_down = _scan_down.points.size();

    // main
    const int NO_POINT = -1000;
    MatrixXd desc = NO_POINT * MatrixXd::Ones(PC_NUM_RING, PC_NUM_SECTOR);

    SCPointType pt;
    float azim_angle, azim_range; // wihtin 2d plane
    int ring_idx, sctor_idx;

 //------------------------------------------------------iris descriptor-----------------------------------------   
    double max_z = 0, min_z = 100;

    for (int i = 0; i < num_pts_scan_down; i++)
    {
        pt.z = _scan_down.points[i].z + LIDAR_HEIGHT;
        if(pt.z > max_z)
        max_z = pt.z
        if(pt.z < min_z)
        min_z = pt.z
    }

    int k = 8;
    double heightInterval = (max_z - min_z)/k;

    int pixelCount[PC_NUM_RING][PC_NUM_SECTOR][k];


    for (int pt_idx = 0; pt_idx < num_pts_scan_down; pt_idx++)
    {
        pt.x = _scan_down.points[pt_idx].x; 
        pt.y = _scan_down.points[pt_idx].y;
        pt.z = _scan_down.points[pt_idx].z + LIDAR_HEIGHT; // naive adding is ok (all points should be > 0).

        // xyz to ring, sector
        azim_range = sqrt(pt.x * pt.x + pt.y * pt.y);
        azim_angle = xy2theta(pt.x, pt.y);

        // if range is out of roi, pass
        if( azim_range > PC_MAX_RADIUS )
            continue;

        ring_idx = std::max( std::min( PC_NUM_RING, int(ceil( (azim_range / PC_MAX_RADIUS) * PC_NUM_RING )) ), 1 );
        sctor_idx = std::max( std::min( PC_NUM_SECTOR, int(ceil( (azim_angle / 360.0) * PC_NUM_SECTOR )) ), 1 );
        //该点处于(ring_idx,sctor_idx)的方块中，随之提取最大高度
        
        int kk = (pt.z-min_z)/heightInterval
        pixelCount[ring_idx-1][sctor_idx-1][kk]=1;
    }

    for ( int row_idx = 0; row_idx < desc.rows(); row_idx++ )
        for ( int col_idx = 0; col_idx < desc.cols(); col_idx++ )
            for(int kkk = 0; kkk < k; kkk++)
               desc(row_idx, col_idx) += pixelCount[row_idx][col_idx][kkk]*2^kkk;

    // reset no points to zero (for cosine dist later)
    for ( int row_idx = 0; row_idx < desc.rows(); row_idx++ )
        for ( int col_idx = 0; col_idx < desc.cols(); col_idx++ )
            if( desc(row_idx, col_idx) == NO_POINT )
                desc(row_idx, col_idx) = 0;

    t_making_desc.toc("PolarContext making");

    return desc;
} // SCManager::makeScancontext